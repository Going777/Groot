/*
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.chocobi.groot.mlkit.kotlin.ml.render

import com.chocobi.groot.mlkit.java.common.samplerender.Framebuffer
import com.google.ar.core.Pose
import com.chocobi.groot.mlkit.java.common.samplerender.Mesh
import com.chocobi.groot.mlkit.java.common.samplerender.SampleRender
import com.chocobi.groot.mlkit.java.common.samplerender.Shader
import com.chocobi.groot.mlkit.java.common.samplerender.Texture
import com.chocobi.groot.mlkit.java.common.samplerender.VertexBuffer
import com.chocobi.groot.mlkit.java.common.samplerender.arcore.SpecularCubemapFilter
//import com.chocobi.groot.mlkit.kotlin.ml.WrappedAnchor
import com.google.ar.core.Anchor
import com.google.ar.core.Trackable
import java.nio.ByteBuffer
import java.nio.ByteOrder

/** Draws a label onto a quad using a text texture generated by [TextTextureCache]. */
class PawnRender {
    companion object {
        private const val TAG = "PawnRender"
    }

    // Virtual object (ARCore pawn)
    lateinit var virtualSceneFramebuffer: Framebuffer
    lateinit var dfgTexture: Texture
    lateinit var cubemapFilter: SpecularCubemapFilter
    lateinit var virtualObjectMesh: Mesh
    lateinit var virtualObjectShader: Shader
    lateinit var virtualObjectAlbedoTexture: Texture
    lateinit var virtualObjectAlbedoInstantPlacementTexture: Texture

//  private val wrappedAnchors = mutableListOf<WrappedAnchor>()

    fun onSurfaceCreated(render: SampleRender) {


        // Virtual object to render (ARCore pawn)
        virtualSceneFramebuffer = Framebuffer(render, /*width=*/ 1, /*height=*/ 1)
        cubemapFilter =
            SpecularCubemapFilter(render, 16, 32)
        dfgTexture =
            Texture(
                render,
                Texture.Target.TEXTURE_2D,
                Texture.WrapMode.CLAMP_TO_EDGE,
                /*useMipmaps=*/ false
            )
        virtualObjectAlbedoTexture =
            Texture.createFromAsset(
                render,
                "models/pawn_albedo.png",
                Texture.WrapMode.CLAMP_TO_EDGE,
                Texture.ColorFormat.SRGB
            )

        virtualObjectAlbedoInstantPlacementTexture =
            Texture.createFromAsset(
                render,
                "models/pawn_albedo_instant_placement.png",
                Texture.WrapMode.CLAMP_TO_EDGE,
                Texture.ColorFormat.SRGB
            )

        val virtualObjectPbrTexture =
            Texture.createFromAsset(
                render,
                "models/pawn_roughness_metallic_ao.png",
                Texture.WrapMode.CLAMP_TO_EDGE,
                Texture.ColorFormat.LINEAR
            )
        virtualObjectMesh = Mesh.createFromAsset(render, "models/pawn.obj")
        virtualObjectShader =
            Shader.createFromAssets(
                render,
                "shaders/environmental_hdr.vert",
                "shaders/environmental_hdr.frag",
                mapOf("NUMBER_OF_MIPMAP_LEVELS" to cubemapFilter.numberOfMipmapLevels.toString())
            )
                .setTexture("u_AlbedoTexture", virtualObjectAlbedoTexture)
                .setTexture(
                    "u_RoughnessMetallicAmbientOcclusionTexture",
                    virtualObjectPbrTexture
                )
                .setTexture("u_Cubemap", cubemapFilter.filteredCubemapTexture)
                .setTexture("u_DfgTexture", dfgTexture)


    }

    val labelOrigin = FloatArray(3)

    /**
     * Draws a label quad with text [label] at [pose]. The label will rotate to face [cameraPose]
     * around the Y-axis.
     */
    fun draw(
        render: SampleRender,
        viewMatrix: FloatArray,
//        pose: Pose,
//        cameraPose: Pose,
//        label: String
    ) {
//        labelOrigin[0] = pose.tx()
//        labelOrigin[1] = pose.ty()
//        labelOrigin[2] = pose.tz()

//        virtualObjectShader
//         Update lighting parameters in the shader
//        updateLightEstimation(frame.lightEstimate, viewMatrix)

        // Visualize anchors created by touch.
//        render.clear(virtualSceneFramebuffer, 0f, 0f, 0f, 0f)
//        for ((anchor, trackable) in
//        wrappedAnchors.filter { it.anchor.trackingState == TrackingState.TRACKING }) {
//            // Get the current pose of an Anchor in world space. The Anchor pose is updated
//            // during calls to session.update() as ARCore refines its estimate of the world.
//            anchor.pose.toMatrix(modelMatrix, 0)
//
//            // Calculate model/view/projection matrices
//            Matrix.multiplyMM(modelViewMatrix, 0, viewMatrix, 0, modelMatrix, 0)
//            Matrix.multiplyMM(modelViewProjectionMatrix, 0, projectionMatrix, 0, modelViewMatrix, 0)
//
//            // Update shader properties and draw
//            virtualObjectShader.setMat4("u_ModelView", modelViewMatrix)
//            virtualObjectShader.setMat4("u_ModelViewProjection", modelViewProjectionMatrix)
//            val texture =
//                if ((trackable as? InstantPlacementPoint)?.trackingMethod ==
//                    InstantPlacementPoint.TrackingMethod.SCREENSPACE_WITH_APPROXIMATE_DISTANCE
//                ) {
//                    virtualObjectAlbedoInstantPlacementTexture
//                } else {
//                    virtualObjectAlbedoTexture
//                }
//            virtualObjectShader.setTexture("u_AlbedoTexture", texture)

        render.draw(virtualObjectMesh, virtualObjectShader, virtualSceneFramebuffer)

    }

}

